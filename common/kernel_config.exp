#!/usr/bin/expect

source  ../common/board_info.exp

# directory and file locations
set workspace_root /home/test/workspace
set src_root $workspace_root/src
set kernel_root $src_root/linux/linux-2.6.x
set custom_kernel $src_root/output/build/linux-custom
set log_loc $workspace_root/logs

# environment settings
if { $board_type == "beagle" } {
    set arch "arm"
    set board_defconfig "beagleboard_defconfig"
    set eth_dev "eth0"
    set usb_eth_dev "eth1"
    set baud_rate "115200"
    set def_uart_port ttyO2

    set console_def "$def_uart_port,${baud_rate}n8"
    set console_null "null"
    set console_args $console_def

    set ipargs "10.100.4.50:10.100.4.174:10.100.4.174:255.255.255.0:beagle:eth0:off"
    set bootargs "setenv bootargs console=\$\{console\} mpurate=\$\{mpurate\} vram=\$\{vram\} omapfb.mode=dvi:\$\{dvimode\} omapfb.debug=y omapdss.def_disp=\$\{defaultdisplay\} root=\$\{mmcroot\} rootfstype=\$\{mmcrootfstype\}"

    set boot_image uImage
} elseif { $board_type == "panda" } {
    set arch "arm"
    set board_defconfig "pandaboard_defconfig"
    set eth_dev "eth0"
    set usb_eth_dev "eth1"
    set baud_rate "115200"
    set def_uart_port ttyO2

    set console_def "$def_uart_port,${baud_rate}n8"
    set console_null "null"
    set console_args $console_def

    set ipargs "10.100.4.50:10.100.4.174:10.100.4.174:255.255.255.0:panda:eth0:off"
    set bootargs "setenv bootargs console=\$\{console\} vram=\$\{vram\} root=\$\{mmcroot\} rootfstype=\$\{mmcrootfstype\}"

    set boot_image uImage
} elseif { $board_type == "bf537-stamp" } {
    set arch "blackfin"
    set board_defconfig "bf537-stamp_defconfig"
    set eth_dev "eth0"
    set usb_eth_dev "eth1"
    set baud_rate "57600"
    set def_uart_port ttyBF0

    set console_def "$def_uart_port,${baud_rate}n8"
    set console_null "null"
    set console_args $console_def

    set ipargs "10.100.4.50:10.100.4.174:10.100.4.174:255.255.255.0:bf537-stamp:eth0:off"
    set bootargs "setenv bootargs root=/dev/mtdblock0 rw ip=10.100.4.50 earlyprintk=serial,uart0,57600 console=ttyBF0,57600"

    set boot_image vmImage
} else {
    set baud_rate "57600"
    set eth_dev "eth0"
    set boot_image uImage
}

set ttydev /dev/ttyS0
set ttyUSBdev /dev/ttyUSB0
set kermit_ttydev $ttydev
set sh_prompt "\[-@].*\[$>#]"
set uboot_prompt "Panda #|OMAP3 beagleboard.org #|bfin>"
set kernel_prompt "\n# |root:\[^>].*>"

set targetip 10.100.4.50
set serverip 10.100.4.174
set count  30
set PING_COUNT  1999
set login_user "root"
set password "blackfin"
set send_slow {1 .1}
set bootaddr_low 0x1000000
set bootaddr_high 0x2000000
set name test
set STRDATA "abcdefghijklmnopqrstuvwxyz0123456789"
set spi_board_type normal

set compressed_kernel_only_image  vmImage
set kernel_and_ext2_image   linux.ext2
set kernel_and_cramfs_image linux.cramfs
set kernel_and_romfs_image  uImage.romfs

set compressed_kernel_and_ext2_image   uImage.ext2
set compressed_kernel_and_cramfs_image uImage.cramfs

set ext2_rootfs_image    rootfs.ext2
set jffs2_rootfs_image   rootfs.jffs2
set yaffs_rootfs_image   rootfs.yaffs
set ubifs_rootfs_image   rootfs.ubifs
set romfs_rootfs_image   rootfs.romfs
set HAVE_JFFS2_IMAGE     0
set HAVE_KERNEL_ONLY_IMAGE     0
set HAVE_ROMFS_IMAGE     0

set linux_version "not found"
set gcc_version "not found"
set map_text "not found"
set map_data "not found"
set map_bss "not found"
set map_rootfs "not found"
set map_stack "not found"
set instruction_cache_boot_flag "not found"
set data_cache_boot_flag "not found"
set TITLE "undefined"

set CACHE_ENABLED           "enabled"
set CACHE_DISABLED          "disabled"

set step_sequence_number    1


proc log_file_name { file_name } {
    return [ exec echo "$file_name" | sed "s/\\.exp/_log/g" | sed "s/\\.\\(\[a-zA-Z\]\\)/_\\1/g" | sed "s/\\(\.\*\\)\\(_\.\*_log\\)\\(\.\*\\)/\\1\\3\\2/g" ]
}

proc title { file_name } {
    return [ exec echo "$file_name" | sed "s/_/ /g" | sed "s/\\.\\/\\(\.\*\\).exp/\\1/g" | tr 'a-z' 'A-Z' ]
}

proc step { message } {
    global step_sequence_number

    puts "\n*******************************************************************"
    puts "STEP $step_sequence_number: $message\n\n"
    send_log "\n************** STEP $step_sequence_number: $message\n\n"
    incr step_sequence_number
}

proc case_pass { casenum } {
    send_user "\nCase $casenum ...PASS\n"
    send_log "\nCase $casenum ...PASS\n"
}

proc case_fail { casenum } {
    global TITLE
    global log_loc

    if {[ catch { eval exec grep -nrl {"$TITLE"} [glob $log_loc/\*/test_summary/pass_summary] } errmsg ]} {
        send_user "\nLast passed test result is not found!!\n"
    } else {
        set pass_files [ eval exec grep -nrl {"$TITLE"} [glob $log_loc/\*/test_summary/pass_summary] ]
        set last_pass_dir [exec echo $pass_files | awk -F/ {{print $9}} | sort -r | tail -n 1 ]

        if {[ catch { exec grep Revision $log_loc/$last_pass_dir/kernel_test_log } errmsg ]} {
            send_user "\nLast passed time: $last_pass_dir. Revision is not found!\n"
        } else {
            set last_pass_ucdist [exec grep Revision $log_loc/$last_pass_dir/kernel_test_log | awk {NR==1 {print $2}} ]
            set last_pass_kernel [exec grep Revision $log_loc/$last_pass_dir/kernel_test_log | awk {NR==2 {print $2}} ]
            send_user "\nLast passed time: $last_pass_dir, ucdist ver: $last_pass_ucdist, kernel ver: $last_pass_kernel\n"
        }
    }

    send_user "\nCase $casenum ...FAIL\n"
    send_log "\nCase $casenum ...FAIL\n"
    send_user "\n$TITLE FAIL\n"
    send_log "$TITLE ............\[FAIL\]\n"

    exit
}

proc all_pass {} {
    global TITLE

    send_log "\n"
    send_log "\n$TITLE ............\[PASS\]\n"
}

proc before_boot {} {
    global def_uart_port
    global baud_rate
    global uboot_prompt
    global console_args

    set timeout 5
    send "setenv console $console_args\r"
    while 1 {
        expect {
            -re $uboot_prompt {
                break
            }
            timeout {
                send_user "Fail: set console in uboot" 
                exit
            }
        }
    }

    set timeout 10
    send "mmcinfo\r"
    while 1 {
        expect {
            -re "Capacity.*$uboot_prompt" {
                break
            }
            timeout {
                send_user "Fail: get mmc info" 
                exit
            }
        }
    }

    set timeout 10
    send "run loaduimage\r"
    while 1 {
        expect {
            -re "bytes read.*$uboot_prompt" {
                break
            }
            timeout {
                send_user "Fail: load uimage in mmc" 
                exit
            }
        }
    }
}
